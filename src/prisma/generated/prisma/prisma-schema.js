module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Aggregatepath {
  count: Int!
}

type Aggregateusers {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createpath(data: pathCreateInput!): path!
  updatepath(data: pathUpdateInput!, where: pathWhereUniqueInput!): path
  updateManypaths(data: pathUpdateManyMutationInput!, where: pathWhereInput): BatchPayload!
  upsertpath(where: pathWhereUniqueInput!, create: pathCreateInput!, update: pathUpdateInput!): path!
  deletepath(where: pathWhereUniqueInput!): path
  deleteManypaths(where: pathWhereInput): BatchPayload!
  createusers(data: usersCreateInput!): users!
  updateusers(data: usersUpdateInput!, where: usersWhereUniqueInput!): users
  updateManyuserses(data: usersUpdateManyMutationInput!, where: usersWhereInput): BatchPayload!
  upsertusers(where: usersWhereUniqueInput!, create: usersCreateInput!, update: usersUpdateInput!): users!
  deleteusers(where: usersWhereUniqueInput!): users
  deleteManyuserses(where: usersWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type path {
  id: ID!
  source: String!
  destination: String!
  scheduledat: DateTime!
  recurring: Boolean
  userid: users!
}

type pathConnection {
  pageInfo: PageInfo!
  edges: [pathEdge]!
  aggregate: Aggregatepath!
}

input pathCreateInput {
  id: ID
  source: String!
  destination: String!
  scheduledat: DateTime!
  recurring: Boolean
  userid: usersCreateOneInput!
}

type pathEdge {
  node: path!
  cursor: String!
}

enum pathOrderByInput {
  id_ASC
  id_DESC
  source_ASC
  source_DESC
  destination_ASC
  destination_DESC
  scheduledat_ASC
  scheduledat_DESC
  recurring_ASC
  recurring_DESC
}

type pathPreviousValues {
  id: ID!
  source: String!
  destination: String!
  scheduledat: DateTime!
  recurring: Boolean
}

type pathSubscriptionPayload {
  mutation: MutationType!
  node: path
  updatedFields: [String!]
  previousValues: pathPreviousValues
}

input pathSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: pathWhereInput
  AND: [pathSubscriptionWhereInput!]
  OR: [pathSubscriptionWhereInput!]
  NOT: [pathSubscriptionWhereInput!]
}

input pathUpdateInput {
  source: String
  destination: String
  scheduledat: DateTime
  recurring: Boolean
  userid: usersUpdateOneRequiredInput
}

input pathUpdateManyMutationInput {
  source: String
  destination: String
  scheduledat: DateTime
  recurring: Boolean
}

input pathWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  destination: String
  destination_not: String
  destination_in: [String!]
  destination_not_in: [String!]
  destination_lt: String
  destination_lte: String
  destination_gt: String
  destination_gte: String
  destination_contains: String
  destination_not_contains: String
  destination_starts_with: String
  destination_not_starts_with: String
  destination_ends_with: String
  destination_not_ends_with: String
  scheduledat: DateTime
  scheduledat_not: DateTime
  scheduledat_in: [DateTime!]
  scheduledat_not_in: [DateTime!]
  scheduledat_lt: DateTime
  scheduledat_lte: DateTime
  scheduledat_gt: DateTime
  scheduledat_gte: DateTime
  recurring: Boolean
  recurring_not: Boolean
  userid: usersWhereInput
  AND: [pathWhereInput!]
  OR: [pathWhereInput!]
  NOT: [pathWhereInput!]
}

input pathWhereUniqueInput {
  id: ID
}

type Query {
  path(where: pathWhereUniqueInput!): path
  paths(where: pathWhereInput, orderBy: pathOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [path]!
  pathsConnection(where: pathWhereInput, orderBy: pathOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): pathConnection!
  users(where: usersWhereUniqueInput!): users
  userses(where: usersWhereInput, orderBy: usersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [users]!
  usersesConnection(where: usersWhereInput, orderBy: usersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): usersConnection!
  node(id: ID!): Node
}

type Subscription {
  path(where: pathSubscriptionWhereInput): pathSubscriptionPayload
  users(where: usersSubscriptionWhereInput): usersSubscriptionPayload
}

type users {
  id: ID!
  email: String!
  phone: String!
  vehicalnumber: String
  createdon: DateTime!
}

type usersConnection {
  pageInfo: PageInfo!
  edges: [usersEdge]!
  aggregate: Aggregateusers!
}

input usersCreateInput {
  id: ID
  email: String!
  phone: String!
  vehicalnumber: String
}

input usersCreateOneInput {
  create: usersCreateInput
  connect: usersWhereUniqueInput
}

type usersEdge {
  node: users!
  cursor: String!
}

enum usersOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  vehicalnumber_ASC
  vehicalnumber_DESC
  createdon_ASC
  createdon_DESC
}

type usersPreviousValues {
  id: ID!
  email: String!
  phone: String!
  vehicalnumber: String
  createdon: DateTime!
}

type usersSubscriptionPayload {
  mutation: MutationType!
  node: users
  updatedFields: [String!]
  previousValues: usersPreviousValues
}

input usersSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: usersWhereInput
  AND: [usersSubscriptionWhereInput!]
  OR: [usersSubscriptionWhereInput!]
  NOT: [usersSubscriptionWhereInput!]
}

input usersUpdateDataInput {
  email: String
  phone: String
  vehicalnumber: String
}

input usersUpdateInput {
  email: String
  phone: String
  vehicalnumber: String
}

input usersUpdateManyMutationInput {
  email: String
  phone: String
  vehicalnumber: String
}

input usersUpdateOneRequiredInput {
  create: usersCreateInput
  update: usersUpdateDataInput
  upsert: usersUpsertNestedInput
  connect: usersWhereUniqueInput
}

input usersUpsertNestedInput {
  update: usersUpdateDataInput!
  create: usersCreateInput!
}

input usersWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  vehicalnumber: String
  vehicalnumber_not: String
  vehicalnumber_in: [String!]
  vehicalnumber_not_in: [String!]
  vehicalnumber_lt: String
  vehicalnumber_lte: String
  vehicalnumber_gt: String
  vehicalnumber_gte: String
  vehicalnumber_contains: String
  vehicalnumber_not_contains: String
  vehicalnumber_starts_with: String
  vehicalnumber_not_starts_with: String
  vehicalnumber_ends_with: String
  vehicalnumber_not_ends_with: String
  createdon: DateTime
  createdon_not: DateTime
  createdon_in: [DateTime!]
  createdon_not_in: [DateTime!]
  createdon_lt: DateTime
  createdon_lte: DateTime
  createdon_gt: DateTime
  createdon_gte: DateTime
  AND: [usersWhereInput!]
  OR: [usersWhereInput!]
  NOT: [usersWhereInput!]
}

input usersWhereUniqueInput {
  id: ID
  email: String
  phone: String
  vehicalnumber: String
}
`
      }
    